

#' @title Generate (Marked) Point Pattern
#' 
#' @description
#' To generate \link[spatstat.geom]{ppp.object}(s), 
#' with none or one or multiple \link[spatstat.geom]{marks}.
#' 
#' @param n \link[base]{integer} scalar, 
#' number of \link[spatstat.geom]{ppp.object}s to generate.
#' Default `1L`.
#' 
#' @param ... one or more named \link[base]{list}s.
#' The first \link[base]{list} specifies the parameters to 
#' generate the \eqn{x}- and \eqn{y}-\link[spatstat.geom]{coords}.
#' The second to last \link[base]{list}s, if available, specify the parameters to
#' generate one or more \link[spatstat.geom]{marks}.
#' 
#' @param win \link[spatstat.geom]{owin} window
#' 
#' @param element1 \link[base]{logical} scalar, whether to return 
#' a \link[spatstat.geom]{ppp.object}, 
#' instead of a \link[base]{length}-`1L` \link[spatstat.geom]{solist},
#' when `n==1L`. Default `TRUE`
#' 
#' @return 
#' Function [.rppp] returns a \link[spatstat.geom]{ppp.object} if `(n==1L)&element1`,
#' otherwise returns a \link[base]{length}-`n` \link[spatstat.geom]{solist}
#' (which also has \link[base]{class} `'ppplist'`).
#' 
#' The returned \link[spatstat.geom]{ppp.object}(s) contain only 
#' \eqn{x}- and \eqn{y}-\link[spatstat.geom]{coords}, 
#' if only one \link[base]{list} is present in the `...` \link[rlang]{dyn-dots} argument.
#' Otherwise, they contain one or more \link[spatstat.geom]{marks}
#' according to the rest of the \link[base]{list}(s) in the `...` argument.
#' 
#' @note
#' The name `rppp()` is too aggressive, which might be claimed in future by package \CRANpkg{spatstat.random}.
#' Therefore we name this function [.rppp] as if it is hidden (see parameter `all.names` of function \link[base]{ls}).
#' 
#' @examples
#' .rppp(rMatClust = list(kappa = c(10,5), scale = c(.15,.06), mu = c(8,4))) # only coords, no marks
#' 
#' plot(r1 <- .rppp(
#'  rMatClust = list(kappa = c(10, 5), scale = c(.15, .06), mu = c(8, 4)), 
#'  rlnorm = list(meanlog = c(3, 5), sdlog = c(.4, .2)),
#'  rnbinom = list(size = c(4, 6), prob = c(.3, .1))
#' ))
#' 
#' plot(r2 <- .rppp(
#'  rpoispp = list(lambda = c(3, 6)),
#'  rlnorm = list(meanlog = c(3, 5), sdlog = c(.4, .2)),
#'  rnbinom = list(size = c(4, 6), prob = c(.3, .1))
#' ))
#' 
#' plot(r <- spatstat.geom::superimpose(r1, r2))
#' 
#' @importFrom cli cli_text col_blue col_magenta
#' @importFrom spatstat.random rMatClust rpoispp
#' @importFrom spatstat.geom owin superimpose.ppp
#' @export
.rppp <- function(
    n = 1L, 
    ..., 
    win = owin(xrange = c(-1,1), yrange = c(-1,1)),
    element1 = TRUE
) {
  
  dots <- list(...)
  dots <- dots[lengths(dots, use.names = FALSE) > 0L]
  
  r <- names(dots)
  names(r) <- r # just easier for developer to debut
  
  par0 <- as.data.frame.list(unlist(dots, recursive = FALSE)) # recycle length
  npar <- .row_names_info(par0, type = 2L)

  par <- lapply(r, FUN = function(i) { # (i = 'rMatClust')
    z <- par0[startsWith(names(par0), prefix = i)]
    names(z) <- gsub(pattern = paste0('^', i, '\\.'), replacement = '', x = names(z))
    return(z) # 'data.frame'
  })
  
  if (!length(par)) stop('length(par) == 0L; not allowed')
  
  message(cli_text(sprintf(fmt = 'Point-pattern generated by {.fn %s}', col_blue(r[1L]))), appendLF = FALSE)
  lapply(r[-1L], FUN = function(i) {
    message(cli_text(sprintf(fmt = 'Marks generated by {.fn %s}', col_magenta(i))), appendLF = FALSE)
  })
  
  fn <- function(j) { # (j = 1L)
    X <- do.call(what = r[1L], args = c(list(win = win), unclass(par[[1L]][j, , drop = FALSE]))) # `X$n` is randomly generated too!
    for (i in seq_along(r)[-1L]) { # length(r) == 1L # compatible
      X <- do.call(what = rmarks_ppp(r[i]), args = c(list(x = X), unclass(par[[i]][j, , drop = FALSE])))
    } # for-loop is the easiest!!!
    return(X)
  } 
  
  ret <- replicate(n = n, expr = {
    do.call(what = superimpose.ppp, args = lapply(seq_len(npar), FUN = fn))
  }, simplify = FALSE)
  
  if ((n == 1L) && element1) return(ret[[1L]])
  
  class(ret) <- c('ppplist', 'solist', class(ret)) # see returned value of ?spatstat.geom::split.ppp
  # to make use of 
  # methods(class = 'solist')
  return(ret)
  
} 





# @seealso 
# Avoid name clash \link[stats]{window}.


#' @title Batch Process of Function [.rppp]
#' 
#' @param n \link[base]{integer} \link[base]{vector}, 
#' numbers of \link[spatstat.geom]{ppp.object}s to generate for each set of parameters
#' 
#' @param ... see examples, for now
#' 
#' @param win \link[spatstat.geom]{owin} window
#' 
#' @returns 
#' Function [grouped_rppp] returns a \link[spatstat.geom]{hyperframe}.
#' 
#' @importFrom spatstat.geom owin hyperframe
#' @export
grouped_rppp <- function(n, ..., win = owin(xrange = c(-1,1), yrange = c(-1,1))) {
  
  dots <- list(...)
  dots <- dots[lengths(dots, use.names = FALSE) > 0L]
  
  tmp <- lapply(dots, FUN = function(.x) { # (.x = dots[[1L]])
    .mapply(FUN = list, dots = lapply(.x, FUN = function(.y) { # (.y = .x[[1L]])
      lapply(seq_len(nrow(.y)), FUN = function(i) .y[i, , drop = TRUE])
    }), MoreArgs = NULL)
  })
  pars <- .mapply(FUN = list, dots = tmp, MoreArgs = NULL)

  suppressMessages(ret0 <- mapply(FUN = function(n, p) { # (p = pars[[1L]])
    do.call(what = .rppp, args = c(p, list(n = n, win = win, element1 = FALSE)))
  }, p = pars, n = n))

  f1_ <- seq_along(n)
  f1 <- rep(f1_, times = n)
  attr(f1, which = 'levels') <- as.character(f1_)
  class(f1) <- 'factor'
  
  ret <- hyperframe(ppp = unlist(ret0, recursive = FALSE), f = f1)
  attr(ret, which = 'group') <- ~f
  class(ret) <- c('groupedHyperframe', class(ret))
  return(ret)
  
}



