

#' @title Generates Marked Point Pattern
#' 
#' @description ..
#' 
#' @param n \link[base]{integer} scalar, 
#' number of \link[spatstat.geom]{ppp} objects to generate.
#' Default `1L`.
#' 
#' @param ... see examples, for now
#' 
#' @param win \link[spatstat.geom]{owin} window, see function \link[spatstat.random]{rMatClust}, etc.
#' 
#' @param element1 \link[base]{logical} scalar, whether to return 
#' a \link[spatstat.geom]{ppp} object, 
#' instead of a \link[base]{length}-`1L` \link[base]{list},
#' when `n==1L`. Default `TRUE`
#' 
#' @return 
#' Function [rmarkpp] returns a \link[spatstat.geom]{ppp} object if `(n==1L)&element1`,
#' otherwise returns a \link[base]{length}-`n` \link[base]{list} of \link[spatstat.geom]{ppp} objects.
#' 
#' @examples
#' r1 = rmarkpp(
#'  rMatClust = list(kappa=c(10,5), scale=c(.15,.06), mu=c(8,4)), 
#'  rlnorm = list(meanlog=c(3,5), sdlog=c(.4,.2))
#' ); plot(r1)
#' 
#' r2 = rmarkpp(
#'  rpoispp = list(lambda=c(3,6)),
#'  rlnorm = list(meanlog=c(3,5), sdlog=c(.4,.2))
#' ); plot(r2)
#' 
#' plot(spatstat.geom::superimpose(r1, r2))
#' 
#' @importFrom cli cli_text col_blue col_magenta
#' @importFrom spatstat.random rMatClust rpoispp
#' @importFrom spatstat.geom owin superimpose.ppp
#' @importFrom stats setNames
#' @export
rmarkpp <- function(
    n = 1L, 
    ..., 
    win = owin(xrange = c(-1,1), yrange = c(-1,1)),
    element1 = TRUE
) {
  
  dots <- list(...)
  dots <- dots[lengths(dots, use.names = FALSE) > 0L]
  
  rfn <- names(dots)
  
  par0 <- as.data.frame.list(unlist(dots, recursive = FALSE)) # recycle length
  par <- lapply(setNames(nm = rfn), FUN = function(i) { # (i = 'rMatClust')
    z <- par0[startsWith(names(par0), prefix = i)]
    names(z) <- gsub(pattern = paste0('^', i, '\\.'), replacement = '', x = names(z))
    return(z) # 'data.frame'
  })
  
  fn <- if (length(par) == 2L) {
    
    #fn_txt <- ns_fun_fromImports(fun = rfn, pkg = 'spatstat.random.tzh')
    # cannot click; not sure why (must from self-package?)
    # cli_text(sprintf(fmt = 'Point-pattern generated by {.run [%s](spatstat.random::%s())}', col_blue(fn_txt[1L]), rfn[1L]))
    # cli_text(sprintf(fmt = 'Marks generated by {.run [%s](?stats::%s)}', col_magenta(fn_txt[2L]), rfn[2L]))
    #message(sprintf(fmt = 'Point-pattern generated by %s', col_blue(fn_txt[1L])))
    #message(sprintf(fmt = 'Marks generated by %s', col_magenta(fn_txt[2L])))
    # end-user may `library()`, then [ns_fun_fromImports] might err
    
    function(j) { # (j = 1L)
      X <- do.call(what = rfn[[1L]], args = c(list(win = win), unclass(par[[1L]][j, , drop = FALSE]))) # `X$n` is randomly generated too!
      do.call(what = rmarks_ppp(rfn[[2L]]), args = c(list(x = X), unclass(par[[2L]][j, , drop = FALSE])))
    } 
    
  } else stop('not supported yet')
  
  ret <- replicate(n = n, expr = do.call(what = superimpose.ppp, args = lapply(seq_len(.row_names_info(par0, type = 2L)), FUN = fn)), simplify = FALSE)
  
  if ((n == 1L) && element1) return(ret[[1L]])
  return(ret)
  
} 






# @seealso 
# Avoid name clash \link[stats]{window}.


#' @title Batch Process of Function [rmarkpp]
#' 
#' @param n \link[base]{integer} \link[base]{vector}, 
#' numbers of \link[spatstat.geom]{ppp} objects to generate for each set of parameters
#' 
#' @param ... see examples, for now
#' 
#' @param win \link[spatstat.geom]{owin} window
#' 
#' @export
batch_rmarkpp <- function(n, ..., win = owin(xrange = c(-1,1), yrange = c(-1,1))) {
  
  dots <- list(...)
  dots <- dots[lengths(dots, use.names = FALSE) > 0L]
  
  tmp <- lapply(dots, FUN = function(.x) { # (.x = dots[[1L]])
    .mapply(FUN = list, dots = lapply(.x, FUN = function(.y) { # (.y = .x[[1L]])
      lapply(seq_len(nrow(.y)), FUN = function(i) .y[i, , drop = TRUE])
    }), MoreArgs = NULL)
  })
  pars <- .mapply(FUN = list, dots = tmp, MoreArgs = NULL)

  suppressMessages(ret0 <- mapply(FUN = function(n, p) { # (p = pars[[1L]])
    do.call(what = rmarkpp, args = c(p, list(n = n, win = win, element1 = FALSE)))
  }, p = pars, n = n))
  
  ret <- unlist(ret0, recursive = FALSE)
  
  id_ <- seq_along(n)
  id <- rep(id_, times = n)
  attr(id, which = 'levels') <- as.character(id_)
  class(id) <- 'factor'
  attr(ret, which = 'data') <- data.frame(id = id)
  attr(ret, which = 'f1') <- id
  return(ret)
  
}

