

#' @title Generate Marked Point Pattern
#' 
#' @description ..
#' 
#' @param n \link[base]{integer} scalar, 
#' number of \link[spatstat.geom]{ppp} objects to generate.
#' Default `1L`.
#' 
#' @param ... see examples, for now
#' 
#' @param win \link[spatstat.geom]{owin} window
#' 
#' @param element1 \link[base]{logical} scalar, whether to return 
#' a \link[spatstat.geom]{ppp} object, 
#' instead of a \link[base]{length}-`1L` \link[spatstat.geom]{solist},
#' when `n==1L`. Default `TRUE`
#' 
#' @return 
#' Function [rmarkpp] returns a \link[spatstat.geom]{ppp} object if `(n==1L)&element1`,
#' otherwise returns a \link[base]{length}-`n` \link[spatstat.geom]{solist}
#' (which also has \link[base]{class} `'ppplist'`) object.
#' 
#' @examples
#' r1 = rmarkpp(
#'  rMatClust = list(kappa = c(10,5), scale = c(.15,.06), mu = c(8,4)), 
#'  rlnorm = list(meanlog = c(3,5), sdlog = c(.4,.2))
#' ); plot(r1)
#' 
#' r2 = rmarkpp(
#'  rpoispp = list(lambda = c(3,6)),
#'  rlnorm = list(meanlog = c(3,5), sdlog = c(.4,.2))
#' ); plot(r2)
#' 
#' plot(spatstat.geom::superimpose(r1, r2))
#' 
#' @importFrom cli cli_text col_blue col_magenta
#' @importFrom spatstat.random rMatClust rpoispp
#' @importFrom spatstat.geom owin superimpose.ppp
#' @export
rmarkpp <- function(
    n = 1L, 
    ..., 
    win = owin(xrange = c(-1,1), yrange = c(-1,1)),
    element1 = TRUE
) {
  
  dots <- list(...)
  dots <- dots[lengths(dots, use.names = FALSE) > 0L]
  
  r <- names(dots)
  names(r) <- r # just easier for developer to debut
  
  par0 <- as.data.frame.list(unlist(dots, recursive = FALSE)) # recycle length
  par <- lapply(r, FUN = function(i) { # (i = 'rMatClust')
    z <- par0[startsWith(names(par0), prefix = i)]
    names(z) <- gsub(pattern = paste0('^', i, '\\.'), replacement = '', x = names(z))
    return(z) # 'data.frame'
  })
  
  fn <- if (length(par) == 2L) {
    
    message(cli_text(sprintf(fmt = 'Point-pattern generated by {.fn %s}', col_blue(r[1L]))), appendLF = FALSE)
    message(cli_text(sprintf(fmt = 'Marks generated by {.fn %s}', col_magenta(r[2L]))), appendLF = FALSE)

    function(j) { # (j = 1L)
      X <- do.call(what = r[1L], args = c(list(win = win), unclass(par[[1L]][j, , drop = FALSE]))) # `X$n` is randomly generated too!
      do.call(what = rmarks_ppp(r[2L]), args = c(list(x = X), unclass(par[[2L]][j, , drop = FALSE])))
    } 
    
  } else stop('not supported yet')
  
  ret <- replicate(n = n, expr = do.call(what = superimpose.ppp, args = lapply(seq_len(.row_names_info(par0, type = 2L)), FUN = fn)), simplify = FALSE)
  
  if ((n == 1L) && element1) return(ret[[1L]])
  
  class(ret) <- c('ppplist', 'solist', class(ret)) # see returned value of ?spatstat.geom::split.ppp
  # to make use of 
  # methods(class = 'solist')
  return(ret)
  
} 






# @seealso 
# Avoid name clash \link[stats]{window}.


#' @title Batch Process of Function [rmarkpp]
#' 
#' @param n \link[base]{integer} \link[base]{vector}, 
#' numbers of \link[spatstat.geom]{ppp} objects to generate for each set of parameters
#' 
#' @param ... see examples, for now
#' 
#' @param win \link[spatstat.geom]{owin} window
#' 
#' @returns 
#' Function [batch_rmarkpp] returns a \link[spatstat.geom]{hyperframe}.
#' 
#' @importFrom spatstat.geom owin hyperframe
#' @export
batch_rmarkpp <- function(n, ..., win = owin(xrange = c(-1,1), yrange = c(-1,1))) {
  
  dots <- list(...)
  dots <- dots[lengths(dots, use.names = FALSE) > 0L]
  
  tmp <- lapply(dots, FUN = function(.x) { # (.x = dots[[1L]])
    .mapply(FUN = list, dots = lapply(.x, FUN = function(.y) { # (.y = .x[[1L]])
      lapply(seq_len(nrow(.y)), FUN = function(i) .y[i, , drop = TRUE])
    }), MoreArgs = NULL)
  })
  pars <- .mapply(FUN = list, dots = tmp, MoreArgs = NULL)

  suppressMessages(ret0 <- mapply(FUN = function(n, p) { # (p = pars[[1L]])
    do.call(what = rmarkpp, args = c(p, list(n = n, win = win, element1 = FALSE)))
  }, p = pars, n = n))

  f1_ <- seq_along(n)
  f1 <- rep(f1_, times = n)
  attr(f1, which = 'levels') <- as.character(f1_)
  class(f1) <- 'factor'
  
  hyperframe(ppp = unlist(ret0, recursive = FALSE), f = f1)
  
}

